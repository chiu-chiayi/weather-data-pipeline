# version: '3.8' # 新版 Docker Compose 支援自動偵測版本，可省略此行

# 一個 service 是由「從哪來(image)」、「怎麼連(網路、port)」、「用甚麼跑(環境、指令)」、「存哪裡(資料卷)」四大要素組成。

x-logging: &default-logging
  logging:
    driver: "json-file"
    options:
      max-size: "10m"
      max-file: "3"

services:
  db:
    image: mysql:9.0
    # container_name:
    restart: unless-stopped
    <<: *default-logging
    environment:
      - TZ=Asia/Taipei
      - MYSQL_ROOT_PASSWORD=${DB_PASSWORD}
      - MYSQL_DATABASE=${DB_NAME}
      # 若要建立一般用戶，才需要下面這兩行，否則先註解掉
      # MYSQL_USER: ${DB_USER}
      # MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      # 把 Docker 管理的虛擬硬碟（mysql_data）掛載到 MySQL 儲存資料的預設位置
      - mysql_data:/var/lib/mysql
      # 自動匯入：將備份檔放到主機的 ./init 資料夾下，並掛載到容器的 /docker-entrypoint-initdb.d 資料夾
      - ./init:/docker-entrypoint-initdb.d
    ports:
      - "3307:3306"
    healthcheck:
      test: [ "CMD", "mysqladmin", "ping", "-h", "db", "-u", "root", "-p${DB_PASSWORD}" ]
      interval: 10s
      timeout: 5s
      retries: 10

  backend:
    build: . # 在當前目錄下尋找 Dockerfile 建立映像檔
    # container_name:
    restart: unless-stopped
    <<: *default-logging
    env_file:
      - .env # 確保這行有加，後端才知道資料庫帳密
    ports:
      - "8000:8000" # 將主機的 8000 埠映射到容器的 8000 埠
    working_dir: /app
    command: uvicorn api.main:app --host 0.0.0.0 --port 8000
    environment:
      - TZ=Asia/Taipei
      - DB_HOST=db
    healthcheck:
      test: [ "CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/docs')" ]
      interval: 5s
      timeout: 5s
      retries: 5
    depends_on:
      db:
        condition: service_healthy

  frontend:
    build: .
    # container_name:
    restart: unless-stopped
    <<: *default-logging
    ports:
      - "8501:8501"
    working_dir: /app
    command: >
      streamlit run web/app.py --server.port 8501 --server.address 0.0.0.0
    environment:
      - TZ=Asia/Taipei
      - PYTHONPATH=/app # 這才是對應 Conda 那招，決定「去哪找 Import」
    healthcheck:
      test: [ "CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8501/')" ]
      interval: 5s
      timeout: 5s
      retries: 5
    depends_on:
      db:
        condition: service_healthy
      backend:
        condition: service_healthy

  crontab:
    build: .
    # container_name:
    restart: unless-stopped
    <<: *default-logging
    env_file:
      - .env
    volumes:
      - ./crontab_file:/etc/cron.d/weather-cron
      - ./logs:/app/logs
    command: >
      sh -c "chmod -R 777 /app/logs &&
             touch /app/logs/cwa_fetch.log &&
             chmod 0666 /app/logs/cwa_fetch.log &&
             chmod 0644 /etc/cron.d/weather-cron &&
             crontab /etc/cron.d/weather-cron &&
             env >> /etc/environment &&
             /usr/local/bin/python -m services.data_collector >> /app/logs/cwa_fetch.log 2>&1 &&
             cron &&
             tail -f /app/logs/cwa_fetch.log"
    environment:
      - TZ=Asia/Taipei
      - DB_HOST=db
    depends_on:
      db:
        condition: service_healthy

# 定義資料庫的資料卷
volumes:
  mysql_data:
